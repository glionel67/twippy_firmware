{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"Batt",
				"BatteryInfos_t"
			],
			[
				"Pid",
				"PidParams_t"
			],
			[
				"HAL",
				"HAL_GetTick"
			],
			[
				"out",
				"outP"
			],
			[
				"uint",
				"uint32_t"
			],
			[
				"uit",
				"uint32_t"
			],
			[
				"al",
				"altMet"
			],
			[
				"qx",
				"qx"
			],
			[
				"qw",
				"qw"
			],
			[
				"Attit",
				"Attitude_t"
			],
			[
				"batt",
				"battType"
			],
			[
				"imu",
				"imu9"
			],
			[
				"sys",
				"systemId"
			],
			[
				"che",
				"cheksum"
			],
			[
				"chec",
				"checksumMsg"
			],
			[
				"NME",
				"NMEA_DECODE_ADDR2"
			],
			[
				"NM",
				"NMEA_DECODE_ADDR1"
			],
			[
				"de",
				"decodeState"
			],
			[
				"uar",
				"uart1"
			],
			[
				"uart",
				"uart1_task"
			],
			[
				"pos",
				"posMode"
			],
			[
				"u",
				"uint8_t"
			],
			[
				"alt",
				"altitude"
			],
			[
				"print",
				"printf\tprintf …"
			],
			[
				"L",
				"LDFLAGS"
			],
			[
				"UART",
				"UART_WRITE"
			],
			[
				"time",
				"timestamps"
			],
			[
				"in",
				"inc\t#include \"…\""
			],
			[
				"angle",
				"angleInc"
			],
			[
				"pid",
				"pid_reset"
			],
			[
				"N",
				"N_MOTORS"
			],
			[
				"MOTOR",
				"MOTOR1"
			],
			[
				"dut",
				"dutyCycle"
			],
			[
				"tick",
				"ticks"
			],
			[
				"int",
				"int32_t"
			],
			[
				"En",
				"EncoderMsg_s"
			],
			[
				"motor",
				"motorControls"
			],
			[
				"MOTO",
				"MOTOR1"
			],
			[
				"Enc",
				"Encoders_t"
			],
			[
				"Mot",
				"Motor_t"
			],
			[
				"duty",
				"dutycycle"
			],
			[
				"pidP",
				"pidPitchRate"
			],
			[
				"PID",
				"PID_PITCH_RATE_ISAT"
			],
			[
				"inc",
				"inc\t#include <…>"
			],
			[
				"mp",
				"mpu9250"
			],
			[
				"m",
				"mpu9250"
			],
			[
				"uin",
				"uint64_t"
			],
			[
				"_",
				"_len"
			],
			[
				"ua",
				"uart1_read"
			],
			[
				"closest",
				"closestPathPoint"
			],
			[
				"cn",
				"controlRate"
			],
			[
				"path",
				"pathEndDistThresh_"
			],
			[
				"refP",
				"refPathFile"
			],
			[
				"ref",
				"refPathFile"
			],
			[
				"param",
				"params"
			],
			[
				"curr",
				"currPose"
			],
			[
				"isP",
				"isRefPath_"
			],
			[
				"pre",
				"prevS"
			],
			[
				"point",
				"points"
			],
			[
				"acc",
				"accFsRange"
			],
			[
				"sample",
				"sampleRate"
			],
			[
				"nPoint",
				"nPoints-1"
			],
			[
				"type",
				"typedef"
			],
			[
				"Path",
				"PathFollower"
			],
			[
				"PathPoint",
				"PathPoint_t"
			],
			[
				"whee",
				"wheel_max_torque_"
			],
			[
				"steet",
				"steerMaxTorque"
			],
			[
				"wh",
				"wheelMaxTorque"
			],
			[
				"wheel",
				"wheel_ref_speeds_"
			],
			[
				"ROS",
				"ROS_INFO"
			],
			[
				"tran",
				"transpose"
			],
			[
				"nb",
				"_nBeacons"
			],
			[
				"q",
				"qNew"
			],
			[
				"good",
				"goodRanges"
			],
			[
				"goo",
				"goodRanges"
			],
			[
				"mag",
				"meanGx"
			],
			[
				"sens",
				"sensors"
			],
			[
				"tiem",
				"timeout"
			],
			[
				"data",
				"dataLen"
			],
			[
				"imuDa",
				"imuDataQueue"
			],
			[
				"size",
				"sizeof"
			],
			[
				"ran",
				"rangingOk"
			],
			[
				"is",
				"isInit"
			],
			[
				"isMovin",
				"isMoving"
			],
			[
				"Ma",
				"MatrixXd"
			],
			[
				"N_",
				"N_AXES"
			],
			[
				"se",
				"segment"
			],
			[
				"Vecro",
				"VectorXd"
			],
			[
				"s",
				"skewGrav"
			],
			[
				"add",
				"addMeasurement"
			],
			[
				"ch",
				"checkCovarianceMatrix"
			],
			[
				"M",
				"Matrix3d"
			],
			[
				"Vector",
				"VectorXd"
			],
			[
				"name",
				"_name"
			],
			[
				"fir",
				"firstState"
			],
			[
				"push",
				"push_back"
			],
			[
				"ed",
				"end"
			],
			[
				"prev",
				"_prevState"
			],
			[
				"tempo",
				"temporalWindow_"
			],
			[
				"nor",
				"norm"
			],
			[
				"sa",
				"saveStates_"
			],
			[
				"n",
				"nPositions"
			],
			[
				"po",
				"position"
			],
			[
				"r",
				"r"
			],
			[
				"range",
				"ranges"
			],
			[
				"nB",
				"nBeacons"
			],
			[
				"init",
				"initialState"
			],
			[
				"la",
				"localNodeHandle"
			],
			[
				"temp",
				"temporalWindow_"
			],
			[
				"delta",
				"deltaTime"
			],
			[
				"pr",
				"processNoiseCovarianceMatrix"
			],
			[
				"Matrix",
				"Matrix3d"
			],
			[
				"pu",
				"push_back"
			],
			[
				"mst",
				"mst2"
			],
			[
				"Acc",
				"AccMeasurement"
			],
			[
				"MIN",
				"MIN_COVARIANCE"
			],
			[
				"Vec",
				"VectorXd"
			],
			[
				"last",
				"lastPredictionTime_"
			],
			[
				"current",
				"currentTime"
			],
			[
				"buffer",
				"stateBuffer_"
			],
			[
				"measu",
				"measurementQueue_"
			],
			[
				"do",
				"double"
			],
			[
				"c",
				"clampAngle"
			],
			[
				"beg",
				"begin"
			],
			[
				"ne",
				"nextState_"
			],
			[
				"next",
				"nextState_"
			],
			[
				"nex",
				"nextState_"
			],
			[
				"end",
				"endl"
			]
		]
	},
	"buffers":
	[
		{
			"file": "src/main.c",
			"settings":
			{
				"buffer_size": 12190,
				"line_ending": "Windows"
			}
		},
		{
			"file": "inc/battery.h",
			"settings":
			{
				"buffer_size": 1747,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/battery.c",
			"settings":
			{
				"buffer_size": 4322,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/**\n * \\file encoder.c\n * \\author Lionel GENEVE\n * \\date 22/02/2019\n * \\version 1.0\n * \\brief Encoder functions used to measure the motor/wheel speed\n */\n\n#include <string.h>\n\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n#include \"queue.h\"\n\n#include \"encoder.h\"\n#include \"main.h\"\n#include \"usTimer.h\"\n\n#define DEBUB_MODULE \"encoder\"\n\n// Timer handler declaration\nTIM_HandleTypeDef TimHandleEnc1;\nTIM_HandleTypeDef TimHandleEnc2;\n\nTIM_Encoder_InitTypeDef enc1;\nTIM_Encoder_InitTypeDef enc2;\n\nstatic const int32_t gear_ratio = 50;\nstatic const int32_t ppt = 64; // Encoder resolution (Number of point per turn)\n//static const int32_t ct_to_rpm = (60000/64); // = 60000/64\n\nstatic int32_t enc1_sum = 0, enc2_sum = 0;\nstatic int32_t enc1_diff = 0, enc2_diff = 0;\nstatic uint16_t enc1_now = 32000, enc2_now = 32000;\nstatic uint16_t enc1_old = 32000, enc2_old = 32000;\nstatic int32_t num = 0, den = 0;\nstatic int32_t enc1_rpm = 0, enc2_rpm = 0;\nstatic uint32_t t1_old = 0, t2_old = 0;\nstatic uint32_t t1_now = 0, t2_now = 0;\nstatic uint32_t dt = 0;\n\n//static xQueueHandle encoderQueue = 0;\nstatic xQueueHandle motorMeasuredSpeedQueue = 0;\n\nint init_encoders(void) \n{\n    int ret = NOK;\n    /*\n    encoderQueue = xQueueCreate(ENCODER_QUEUE_SIZE, sizeof(Encoders_t));\n    if (encoderQueue == 0) {\n        printf(\"init_encoders: encoderQueue creation NOK\\r\\n\");\n        return -1;\n    }\n    else {\n        printf(\"init_encoders: encoderQueue creation OK\\r\\n\");\n    }\n    */\n    motorMeasuredSpeedQueue = xQueueCreate(ENCODER_QUEUE_SIZE, sizeof(MotorMeasuredSpeed_t));\n    if (motorMeasuredSpeedQueue == 0)\n    {\n        printf(\"init_encoders: motorMeasuredSpeedQueue creation NOK\\r\\n\");\n        return NOK;\n    }\n    else\n        printf(\"init_encoders: motorMeasuredSpeedQueue creation OK\\r\\n\");\n\n    // Init. encoders timers\n    // TIM3\n    TIM_ENC1_CLK_ENABLE();\n    TimHandleEnc1.Instance                  = TIM_ENC1;\n    TimHandleEnc1.Init.Prescaler            = 0;\n    TimHandleEnc1.Init.Period               = 0xFFFF;\n    TimHandleEnc1.Init.ClockDivision        = TIM_CLOCKDIVISION_DIV1;\n    TimHandleEnc1.Init.CounterMode          = TIM_COUNTERMODE_UP;\n    TimHandleEnc1.Init.RepetitionCounter    = 0;\n\n    enc1.EncoderMode    = TIM_ENCODERMODE_TI12;\n    enc1.IC1Polarity    = TIM_ICPOLARITY_RISING; //TIM_ICPolarity_BothEdge\n    enc1.IC1Selection   = TIM_ICSELECTION_DIRECTTI;\n    enc1.IC1Prescaler   = TIM_ICPSC_DIV1;\n    enc1.IC1Filter      = 0x00;\n    enc1.IC2Polarity    = TIM_ICPOLARITY_RISING;\n    enc1.IC2Selection   = TIM_ICSELECTION_DIRECTTI;\n    enc1.IC2Prescaler   = TIM_ICPSC_DIV1;\n    enc1.IC2Filter      = 0x00;\n\n    if (HAL_OK != HAL_TIM_Encoder_Init(&TimHandleEnc1, &enc1))\n        return NOK;\n\n    TIM_ENC1->CNT = enc1_now = enc1_old;\n    t1_old = (uint32_t)(get_us_time() / 1000); //HAL_GetTick();\n    ret = HAL_TIM_Encoder_Start(&TimHandleEnc1, TIM_CHANNEL_1 | TIM_CHANNEL_2); // TIM_CHANNEL_ALL\n    //ret = HAL_TIM_Encoder_Start_IT(TimHandleEnc1, TIM_CHANNEL_1 | TIM_CHANNEL_2); // TIM_CHANNEL_ALL\n    if (HAL_OK != ret)\n        return NOK;\n\n    // TIM4\n    TIM_ENC2_CLK_ENABLE();\n    TimHandleEnc2.Instance                  = TIM_ENC2;\n    TimHandleEnc2.Init.Prescaler            = 0;\n    TimHandleEnc2.Init.Period               = 0xFFFF;\n    TimHandleEnc2.Init.ClockDivision        = TIM_CLOCKDIVISION_DIV1;\n    TimHandleEnc2.Init.CounterMode          = TIM_COUNTERMODE_UP;\n    TimHandleEnc2.Init.RepetitionCounter    = 0;\n\n    enc2.EncoderMode    = TIM_ENCODERMODE_TI12;\n    enc2.IC1Polarity    = TIM_ICPOLARITY_RISING; //TIM_ICPOLARITY_BOTHEDGE;\n    enc2.IC1Selection   = TIM_ICSELECTION_DIRECTTI;\n    enc2.IC1Prescaler   = TIM_ICPSC_DIV1;\n    enc2.IC1Filter      = 0x00;\n    enc2.IC2Polarity    = TIM_ICPOLARITY_RISING; //TIM_ICPOLARITY_BOTHEDGE;\n    enc2.IC2Selection   = TIM_ICSELECTION_DIRECTTI;\n    enc2.IC2Prescaler   = TIM_ICPSC_DIV1;\n    enc2.IC2Filter      = 0x00;\n\n    if (HAL_OK != HAL_TIM_Encoder_Init(&TimHandleEnc2, &enc2))\n        return NOK;\n\n    TIM_ENC2->CNT = enc2_now = enc2_old;\n    t2_old = (uint32_t)(get_us_time() / 1000); //HAL_GetTick();\n    ret = HAL_TIM_Encoder_Start(&TimHandleEnc2, TIM_CHANNEL_1 | TIM_CHANNEL_2); // TIM_CHANNEL_ALL\n    //ret = HAL_TIM_Encoder_Start_IT(TimHandleEnc2, TIM_CHANNEL_1 | TIM_CHANNEL_2); // TIM_CHANNEL_ALL\n    if (HAL_OK != ret)\n        return NOK;\n\n    enc1_sum = 0, enc2_sum = 0;\n    \n    return OK;\n} // init_encoders\n\nuint32_t enc1_get_direction(void)\n{\n    return !__HAL_TIM_IS_TIM_COUNTING_DOWN(&TimHandleEnc1);\n}\n\nuint32_t enc2_get_direction(void)\n{\n    return !__HAL_TIM_IS_TIM_COUNTING_DOWN(&TimHandleEnc2);\n}\n\nint32_t enc1_get_counts(void)\n{\n    enc1_now = TIM_ENC1->CNT;\n    TIM_ENC1->CNT = enc1_old;\n    enc1_diff = (int32_t)(enc1_now - enc1_old);\n    enc1_sum += enc1_diff;\n    return enc1_sum;\n}\n\nint32_t enc2_get_counts(void)\n{\n    enc2_now = TIM_ENC2->CNT;\n    TIM_ENC2->CNT = enc2_old;\n    enc2_diff = (int32_t)(enc2_now - enc2_old);\n    enc2_sum += enc2_diff;\n    return enc2_sum;\n}\n\nint32_t enc1_get_rpm(void)\n{\n    enc1_now = TIM_ENC1->CNT;\n    TIM_ENC1->CNT = enc1_old;\n    t1_now = (uint32_t)(get_us_time() / 1000); //HAL_GetTick();\n    enc1_diff = enc1_now - enc1_old;\n\n    dt = t1_now - t1_old;\n    t1_old = t1_now;\n\n    den = (int32_t)((int32_t)dt * gear_ratio);\n    num = (enc1_diff * 60000) / ppt;\n    enc1_rpm = num / den;\n    return enc1_rpm;\n}\n\nint32_t enc2_get_rpm(void)\n{\n    enc2_now = TIM_ENC2->CNT;\n    TIM_ENC2->CNT = enc2_old;\n    t2_now = (uint32_t)(get_us_time() / 1000); //HAL_GetTick();\n    enc2_diff = enc2_now - enc2_old;\n\n    dt = t2_now - t2_old;\n    t2_old = t2_now;\n\n    den = (int32_t)((int32_t)dt * gear_ratio);\n    num = (enc2_diff * 60000) / ppt;\n    enc2_rpm = num / den;\n    return enc2_rpm;\n}\n\nvoid enc1_get_cts_and_rpm(int32_t* cts, int32_t* rpm)\n{\n    enc1_now = TIM_ENC1->CNT;\n    TIM_ENC1->CNT = enc1_old;\n    t1_now = (uint32_t)(get_us_time() / 1000); //HAL_GetTick();\n    (*cts) = enc1_now - enc1_old;\n\n    dt = t1_now - t1_old;\n    t1_old = t1_now;\n\n    den = (int32_t)((int32_t)dt * gear_ratio);\n    num = ((*cts) * 60000) / ppt;\n    (*rpm) = num / den;\n}\n\nvoid enc2_get_cts_and_rpm(int32_t* cts, int32_t* rpm)\n{\n    enc2_now = TIM_ENC2->CNT;\n    TIM_ENC2->CNT = enc2_old;\n    t2_now = (uint32_t)(get_us_time() / 1000); //HAL_GetTick();\n    (*cts) = enc2_now - enc2_old;\n\n    dt = t2_now - t2_old;\n    t2_old = t2_now;\n\n    den = (int32_t)((int32_t)dt * gear_ratio);\n    num = ((*cts) * 60000) / ppt;\n    (*rpm) = num / den;\n}\n\nvoid enc_get_cts_and_rpm(int32_t* cts1, int32_t* rpm1, \n        int32_t* cts2, int32_t* rpm2)\n{\n    enc1_now = TIM_ENC1->CNT;\n    enc2_now = TIM_ENC2->CNT;\n    TIM_ENC1->CNT = enc1_old;\n    TIM_ENC2->CNT = enc2_old;\n\n    t1_now = (uint32_t)(get_us_time() / 1000); //HAL_GetTick();\n\n    (*cts1) = (int32_t)(enc1_now - enc1_old);\n    (*cts2) = (int32_t)(enc2_now - enc2_old);\n\n    dt = t1_now - t1_old;\n    t1_old = t1_now;\n\n    den = (int32_t)((int32_t)dt * gear_ratio);\n    num = ((*cts1) * 60000) / ppt;\n    enc1_rpm = num / den;\n    num = ((*cts2) * 60000) / ppt;\n    enc2_rpm = num / den;\n\n    (*rpm1) = (int16_t)enc1_rpm;\n    (*rpm2) = (int16_t)enc2_rpm;\n}\n\nvoid enc_test_task(void* _params)\n{\n    uint32_t ticks = 0;\n    int32_t enc1 = 0, enc2 = 0;\n\n    if (_params != 0) { }\n\n    while (1)\n    {\n        enc1 = enc1_get_counts();\n        enc2 = enc2_get_counts();\n        ticks = (uint32_t)(get_us_time() / 1000); //HAL_GetTick();\n        printf(\"%lu,enc1=%ld,enc2=%ld\\r\\n\", ticks, enc1, enc2);\n        vTaskDelay(500/portTICK_RATE_MS);\n    }\n\n    vTaskDelete(NULL);\n}\n\nvoid encoder_task(void* _params)\n{\n    uint8_t count = 0;\n    //Encoders_t encoders;\n    MotorMeasuredSpeed_t motorMeasuredSpeeds;\n    int32_t ticks[N_MOTORS] = { 0, };\n    TickType_t xLastWakeTime;\n    const TickType_t xPeriod = pdMS_TO_TICKS(ENCODER_MEASUREMENT_PERIOD_MS);\n\n    if (_params != 0) { }\n\n    //memset((void*)&encoders, 0, sizeof(Encoders_t));\n    memset((void*)&motorMeasuredSpeeds, 0, sizeof(MotorMeasuredSpeed_t));\n\n    xLastWakeTime = xTaskGetTickCount();\n\n    while (1)\n    {\n        // Get timestamp\n        //encoders.timestamp = (float)get_us_time() * (float)1e-6;\n        motorMeasuredSpeeds.timestamp = (float)get_us_time() * (float)1e-6;\n        \n        // Read ticks and compute RPM\n        taskENTER_CRITICAL();\n        enc1_now = TIM_ENC1->CNT;\n        enc2_now = TIM_ENC2->CNT;\n        TIM_ENC1->CNT = enc1_old;\n        TIM_ENC2->CNT = enc2_old;\n        taskEXIT_CRITICAL();\n\n        t1_now = HAL_GetTick(); // (uint32_t)(get_us_time() / 1000);\n\n        // Compute tick difference\n        //encoders.encoders[MOTOR1].tick = (int32_t)(enc1_now - enc1_old);\n        //encoders.encoders[MOTOR2].tick = (int32_t)(enc2_now - enc2_old);\n        ticks[MOTOR1] = (int32_t)(enc1_now - enc1_old);\n        ticks[MOTOR2] = (int32_t)(enc2_now - enc2_old);\n\n        dt = t1_now - t1_old;\n        t1_old = t1_now;\n\n        // Convert ticks to RPM\n        den = (int32_t)((int32_t)dt * gear_ratio);\n        //num = (encoders.encoders[MOTOR1].tick * 60000) / ppt;\n        num = (ticks[MOTOR1] * 60000) / ppt;\n        //encoders.encoders[MOTOR1].rpm = num / den;\n        motorMeasuredSpeeds.speed[MOTOR1] = (float)num / (float)den;\n        //num = (encoders.encoders[MOTOR2].tick * 60000) / ppt;\n        num = (ticks[MOTOR2] * 60000) / ppt;\n        //encoders.encoders[MOTOR2].rpm = num / den;\n        motorMeasuredSpeeds.speed[MOTOR2] = (float)num / (float)den;\n\n        // Send encoder data\n        //xQueueOverwrite(encoderQueue, &encoders);\n        xQueueOverwrite(motorMeasuredSpeedQueue, &motorMeasuredSpeeds);\n\n        count++;\n        //if (count >= ENCODER_MEASUREMENT_PERIOD_MS/2)\n        if (count >= 1)\n        {\n            count = 0;\n            // printf(\"%3.3f,%3.3f\\r\\n\",\n            //  motorMeasuredSpeeds.speed[MOTOR1],\n            //  motorMeasuredSpeeds.speed[MOTOR2]);\n        }\n\n        vTaskDelayUntil(&xLastWakeTime, xPeriod);\n    }\n\n    vTaskDelete(NULL);\n} // encoder_task\n\n//uint8_t encoder_read_data(Encoders_t* enc, TickType_t xTicksToWait) {\n//  return (pdTRUE == xQueueReceive(encoderQueue, enc, xTicksToWait));\n//}\n\nuint8_t encoder_read_motor_measured_speed(MotorMeasuredSpeed_t* data, TickType_t xTicksToWait)\n{\n    return (pdTRUE == xQueueReceive(motorMeasuredSpeedQueue, data, xTicksToWait));\n}",
			"file": "src/encoder.c",
			"file_size": 10631,
			"file_write_time": 132317652158220959,
			"settings":
			{
				"buffer_size": 10288,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "Makefile",
			"settings":
			{
				"buffer_size": 7573,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/ellion/Workspace/twippy_firmware",
		"/home/ellion/Workspace/twippy_firmware/inc",
		"/home/ellion/Workspace/twippy_firmware/src"
	],
	"file_history":
	[
		"/home/ellion/Workspace/twippy_firmware/inc/encoder.h",
		"/home/ellion/Workspace/twippy_firmware/src/uart1.c",
		"/home/ellion/Workspace/twippy_firmware/src/gpio.c",
		"/home/ellion/Workspace/twippy_firmware/inc/adc.h",
		"/home/ellion/Workspace/twippy_firmware/src/adc.c",
		"/home/ellion/Workspace/twippy_firmware/inc/main.h",
		"/home/ellion/Workspace/twippy_firmware/src/main.c",
		"/home/ellion/Workspace/twippy_firmware/src/uart2.c",
		"/home/ellion/Workspace/twippy_firmware/hal/inc/stm32f4xx_hal_uart.h",
		"/home/ellion/Workspace/twippy_firmware/src/usTimer.c",
		"/home/ellion/Workspace/twippy_firmware/src/pid_controller.c",
		"/home/ellion/Workspace/twippy_firmware/inc/com.h",
		"/home/ellion/Workspace/twippy_firmware/inc/config.h",
		"/home/ellion/Workspace/twippy_firmware/src/com.c",
		"/home/ellion/Workspace/twippy_firmware/inc/pid_controller.h",
		"/home/ellion/Workspace/twippy_firmware/src/motor_control.c",
		"/home/ellion/Workspace/twippy_firmware/inc/motor_control.h",
		"/home/ellion/Workspace/twippy_firmware/src/gps.c",
		"/home/ellion/Workspace/twippy_firmware/hal/inc/stm32f4xx_hal_def.h",
		"/home/ellion/Workspace/twippy_firmware/inc/servo.h",
		"/home/ellion/Workspace/twippy_firmware/inc/spi.h",
		"/home/ellion/Workspace/twippy_firmware/inc/ubx.h",
		"/home/ellion/Workspace/twippy_firmware/inc/usTimer.h",
		"/home/ellion/Workspace/twippy_firmware/inc/mpu9250.h",
		"/home/ellion/Workspace/twippy_firmware/inc/motor.h",
		"/home/ellion/Workspace/twippy_firmware/inc/gpio.h",
		"/home/ellion/Workspace/twippy_firmware/inc/imu.h",
		"/home/ellion/Workspace/twippy_firmware/inc/led.h",
		"/home/ellion/Workspace/twippy_firmware/inc/i2c1.h",
		"/home/ellion/Workspace/twippy_firmware/inc/i2c2.h",
		"/home/ellion/Workspace/twippy_firmware/src/i2c1.c",
		"/home/ellion/Workspace/twippy_firmware/inc/gps.h",
		"/home/ellion/Workspace/twippy_firmware/inc/battery.h",
		"/home/ellion/Workspace/twippy_firmware/inc/buzzer.h",
		"/home/ellion/Workspace/twippy_firmware/src/battery.c",
		"/home/ellion/Workspace/twippy_firmware/inc/ahrs.h",
		"/home/ellion/Workspace/twippy_firmware/src/imu.c",
		"/home/ellion/Workspace/twippy_firmware/src/encoder.c",
		"/home/ellion/Workspace/twippy_firmware/src/led.c",
		"/home/ellion/Workspace/twippy_firmware/inc/uart1.h",
		"/home/ellion/Workspace/twippy_firmware/src/uart3.c",
		"/home/ellion/Workspace/twippy_firmware/inc/uart3.h",
		"/home/ellion/Workspace/twippy_firmware/inc/uart2.h",
		"/home/ellion/Workspace/twippy_firmware/hal/inc/stm32f4xx_hal_gpio.h",
		"/home/ellion/Workspace/twippy_firmware/hal/inc/stm32f4xx_hal.h",
		"/home/ellion/Workspace/twippy_firmware/src/mavlink_uart.c",
		"/home/ellion/Workspace/twippy_firmware/inc/state_machine.h",
		"/home/ellion/Workspace/twippy_firmware/src/motor.c",
		"/home/ellion/Workspace/twippy_firmware/src/buzzer.c",
		"/home/ellion/Workspace/twippy_firmware/README.md",
		"/home/ellion/Workspace/twippy_firmware/src/spi.c",
		"/home/ellion/Workspace/twippy_firmware/Makefile",
		"/home/user/Workspace/twippy_firmware/src/motor.c",
		"/home/user/Workspace/twippy_firmware/inc/servo.h",
		"/home/user/Workspace/twippy_firmware/src/servo.c",
		"/home/user/Workspace/twippy_firmware/hal/inc/stm32f4xx_hal_rcc_ex.h",
		"/home/user/Workspace/twippy_firmware/hal/inc/stm32f4xx_hal_rcc.h",
		"/home/user/Workspace/twippy_firmware/src/led.c",
		"/home/user/Workspace/twippy_firmware/src/i2c1.c",
		"/home/user/Workspace/twippy_firmware/src/encoder.c",
		"/home/user/Workspace/twippy_firmware/inc/main.h",
		"/home/user/Workspace/twippy_firmware/src/usTimer.c",
		"/home/user/Workspace/twippy_firmware/src/battery.c",
		"/home/user/Workspace/twippy_firmware/hal/src/stm32f4xx_hal_rcc.c",
		"/home/user/Workspace/twippy_firmware/src/buzzer.c",
		"/home/user/Workspace/twippy_firmware/src/balance_control.c",
		"/home/user/Workspace/twippy_firmware/src/ahrs.c",
		"/home/user/Workspace/twippy_firmware/src/mavlink_uart.c",
		"/home/user/Workspace/twippy_firmware/src/uart3.c",
		"/home/user/Workspace/twippy_firmware/inc/mavlink_uart.h",
		"/home/user/Workspace/twippy_firmware/src/imu.c",
		"/home/user/Workspace/twippy_firmware/src/mpu9250.c",
		"/home/user/Workspace/twippy_firmware/src/uart1.c",
		"/home/user/Workspace/twippy_firmware/src/gps.c",
		"/home/user/Workspace/twippy_firmware/README.md",
		"/home/user/Workspace/twippy_firmware/inc/usTimer.h",
		"/home/user/Workspace/twippy_firmware/inc/gps.h",
		"/home/user/Workspace/twippy_firmware/Makefile",
		"/home/user/Workspace/twippy_firmware/src/main_test.c",
		"/home/user/Workspace/twippy_firmware/inc/motor.h",
		"/home/user/Workspace/twippy_firmware/src/main.c",
		"/home/user/Workspace/twippy_firmware/src/adc.c",
		"/home/user/Workspace/twippy_firmware/inc/encoder.h",
		"/home/user/Workspace/twippy_firmware/src/gpio.c",
		"/home/user/Workspace/twippy_firmware/hal/src/stm32f4xx_hal_uart.c",
		"/home/user/Workspace/twippy_firmware/hal/inc/stm32f4xx_hal_uart.h",
		"/home/user/Workspace/twippy_firmware/hal/inc/stm32f4xx_hal_gpio.h",
		"/home/user/Workspace/twippy_firmware/inc/imu.h",
		"/home/ellion/Workspace/twippy_firmware/inc/nmea.h",
		"/home/ellion/Workspace/twippy_firmware/src/ahrs.c",
		"/home/ellion/Workspace/twippy_firmware/src/mpu9250.c",
		"/home/user/Workspace/twippy_firmware/inc/nmea.h",
		"/home/user/Workspace/twippy_firmware/src/nmea.c",
		"/home/user/Workspace/twippy_firmware/src/uart2.c",
		"/home/user/Workspace/twippy_firmware/hal/src/stm32f4xx_hal_gpio.c",
		"/home/user/Workspace/twippy_firmware/mavlink/protocol.h",
		"/home/user/Workspace/twippy_firmware/hal/inc/stm32f4xx_hal_gpio_ex.h",
		"/home/user/Workspace/twippy_firmware/mavlink/mavlink_helpers.h",
		"/home/user/Workspace/twippy_firmware/mavlink/common/mavlink_msg_heartbeat.h",
		"/home/user/Workspace/twippy_firmware/mavlink/mavlink_types.h",
		"/home/user/Workspace/twippy_firmware/hal/inc/stm32f4xx_hal_def.h",
		"/home/user/Workspace/twippy_firmware/inc/uart1.h",
		"/home/user/Workspace/twippy_firmware/src/i2c2.c",
		"/home/user/Workspace/twippy_firmware/hal/src/stm32f4xx_hal.c",
		"/home/user/Workspace/twippy_firmware/hal/inc/Legacy/stm32_hal_legacy.h",
		"/home/user/Workspace/twippy_firmware/src/spi.c",
		"/home/user/Workspace/twippy_firmware/hal/inc/stm32f4xx_hal_i2c.h",
		"/home/user/Workspace/twippy_firmware/inc/i2c2.h",
		"/home/user/Workspace/twippy_firmware/inc/uart3.h",
		"/home/user/Workspace/twippy_firmware/inc/uart2.h",
		"/home/user/Workspace/twippy_firmware/FreeRTOS/inc/queue.h",
		"/home/user/Workspace/twippy_firmware/CMSIS/inc/stm32f446xx.h",
		"/home/user/Workspace/twippy_firmware/src/syscalls.c",
		"/home/user/Workspace/twippy_firmware/hal/inc/stm32f4xx_hal_usart.h",
		"/home/user/Workspace/twippy_firmware/src/pid_controller.c",
		"/home/user/Workspace/twippy_firmware/src/motor_control.c",
		"/home/user/Workspace/twippy_firmware/src/com.c",
		"/home/user/Workspace/twippy_firmware/inc/led.h",
		"/home/user/Workspace/twippy_firmware/src/stm32f4xx_it.c",
		"/home/user/Workspace/twippy_firmware/inc/stm32f4xx_it.h",
		"/home/user/Workspace/twippy_firmware/FreeRTOS/inc/portmacro.h",
		"/home/user/Workspace/twippy_firmware/hal/src/stm32f4xx_hal_cortex.c",
		"/home/user/Workspace/twippy_firmware/inc/stm32f4xx_hal_conf.h",
		"/home/user/Workspace/twippy_firmware/hal/inc/stm32f4xx_hal_conf_template.h",
		"/home/user/Workspace/twippy_firmware/inc/FreeRTOSConfig.h",
		"/home/user/Workspace/twippy_firmware/FreeRTOS/src/queue.c",
		"/home/user/Workspace/twippy_firmware/CMSIS/inc/core_cm4.h",
		"/home/user/Workspace/twippy_firmware/src/mavlink_interface.cpp"
	],
	"find":
	{
		"height": 81.0
	},
	"find_in_files":
	{
		"height": 152.0,
		"where_history":
		[
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"process_battery",
			"LED1",
			"imuDataReady",
			"mavlinkReadMessage",
			"sendImuData",
			"send",
			"mavlinkS",
			"uart",
			"uart3",
			"__HAL_RCC_UART3_CLK_ENABLE",
			"__HAL_RCC_USART3_CLK_ENABLE",
			"GPIO_PIN_9",
			"_bat->",
			"mavlinkWriteMessage",
			"UART_WRITE",
			"Calibration res",
			"GPIO_PIN_10",
			"__HAL_RCC_SYSCFG_CLK_ENABLE",
			"uart",
			"decodeMsg",
			"DATASIZE",
			"print_msg",
			"print_ms",
			"print",
			"HAL_UART_IRQHandler",
			"UART_WaitOnFlagUntilTimeout",
			"__HAL_UART_GET_FLAG",
			"__HAL_UART_GET_IT_SOURCE",
			"cheksum",
			"checksumField",
			"atof",
			"double",
			"HAL_InitTick",
			"USART_FLAG_TXE",
			"USART_ReceiveData",
			"uart1RxQueue",
			"huart->gState",
			"UART_FLAG_TC",
			"clear",
			"UART_IT_RXNE",
			"Receive",
			"rxByte",
			"i2c1",
			"I2cHandle1",
			"failed",
			"uart",
			"mavlinkWriteMessage",
			"uart",
			"len",
			"mavlinkWriteMessage",
			"uart",
			"lastStatus",
			"mavlinkMessages_",
			"controlStatus_",
			"port_",
			"mavlinkMsgQueue",
			"xQueueSend",
			"writeMessage",
			"mavlinkMessages",
			"motorMeasuredSpeedQueue",
			"encoder_task",
			"time_stamps",
			"this_timestamps",
			"current_messages",
			"GPIO_PIN_14",
			"GPIO_PIN_15",
			"isCalibrated",
			"mpu9250_static_calibration",
			"sinusoidSignal",
			"squareSignal",
			"voltageToPwm",
			"dutyCycle",
			"motorsQueue",
			"Motors_t",
			"Motor_t",
			"voltageToPwm",
			"MotorControl_t",
			"EncoderMsg_t",
			"sinusoidSignal",
			"myQueue",
			"enc1_rpm",
			"HAL_GetTick",
			"Encoders_t",
			"__HAL_TIM_DIRECTION_STATUS",
			"TIM1_",
			"TIM1",
			"motors[",
			"motors.",
			"motors",
			"motorsStatus",
			"RCC_DCK",
			"N_MOTORS",
			"GPIO_PIN_5",
			"encoderQueue",
			"mpu9250_test_mag",
			"mpu9250_test",
			"atan2",
			"PI",
			"nTries",
			"mag_sens",
			"m_gain",
			"mag_sens",
			"register_data",
			"reg_data_idx",
			"__HAL_RCC_TIM6_CLK_ENABLE",
			"__HAL_RCC_TIM",
			"uart1Queue",
			"myQueue",
			"data",
			"xPortSysTickHandler",
			"TickPriority",
			"uwTick",
			"mthumb",
			"buffer",
			"SMPLRT_DIV",
			"a_gain",
			"pub_control_command",
			"ts_distance_scan_to_map",
			"float",
			"NB_AXES",
			"buffer",
			"wheel_max_accel_",
			"rangeBiasVar",
			"stamp",
			"addDeltaErrors",
			"finalizeUpdate",
			"PBxn",
			"x"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"battery.",
			"i2c2",
			"I2cHandle2",
			"mavlinkMessages",
			"mavlinkMessages_",
			"timestamps",
			"mavlinkMessages",
			"motorQueue",
			"motors.motors[",
			"motors.motors",
			"motors",
			"double",
			"N_AXES",
			"xn",
			"TwistMeasurement"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 2,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "src/main.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12190,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7801.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "inc/battery.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1747,
						"regions":
						{
						},
						"selection":
						[
							[
								1681,
								1681
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1560.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "src/battery.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4322,
						"regions":
						{
						},
						"selection":
						[
							[
								4322,
								4322
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2057.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "src/encoder.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10288,
						"regions":
						{
						},
						"selection":
						[
							[
								10200,
								10149
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 12086.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "Makefile",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7573,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Makefile/Makefile.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 3120.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 56.0
	},
	"input":
	{
		"height": 56.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "twippy_firmware.sublime-project",
	"replace":
	{
		"height": 104.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 531.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
